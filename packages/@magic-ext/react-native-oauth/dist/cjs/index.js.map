{
  "version": 3,
  "sources": ["../../src/index.ts", "../../src/crypto.ts", "../../src/types.ts"],
  "sourcesContent": ["import * as WebBrowser from 'expo-web-browser';\nimport { Extension } from '@magic-sdk/react-native';\nimport { createCryptoChallenge } from './crypto';\nimport {\n  OAuthErrorData,\n  OAuthPayloadMethods,\n  OAuthRedirectConfiguration,\n  OAuthRedirectError,\n  OAuthRedirectResult,\n} from './types';\n\nexport class OAuthExtension extends Extension.Internal<'oauth'> {\n  name = 'oauth' as const;\n  config = {};\n  compat = {\n    'magic-sdk': false,\n    '@magic-sdk/react-native': '>=2.7.0',\n  };\n\n  public loginWithPopup(configuration: OAuthRedirectConfiguration) {\n    return this.utils.createPromiEvent<OAuthRedirectResult>(async (resolve, reject) => {\n      try {\n        const { provider, query, redirectURI } = await createURI.call(this, configuration);\n        const url = `https://auth.magic.link/v1/oauth2/${provider}/start?${query}`;\n\n        /**\n         * Response Type\n         * https://docs.expo.io/versions/latest/sdk/webbrowser/#returns\n         */\n        const res = await WebBrowser.openAuthSessionAsync(url, redirectURI, {});\n\n        if (res.type === 'success') {\n          const queryString = new URL(res.url).search;\n\n          resolve(getResult.call(this, queryString.toString()));\n        } else {\n          reject(this.createError<object>(res.type, 'User has cancelled the authentication', {}));\n        }\n      } catch (err: any) {\n        reject(\n          this.createError<object>(err.message, 'An error has occurred', {\n            err,\n          }),\n        );\n      }\n    });\n  }\n}\n\nconst OAUTH_REDIRECT_METADATA_KEY = 'oauth_redirect_metadata';\n\nexport async function createURI(this: OAuthExtension, configuration: OAuthRedirectConfiguration) {\n  // Bust any old, in-progress OAuth flows.\n  await this.utils.storage.removeItem(OAUTH_REDIRECT_METADATA_KEY);\n\n  // Unpack configuration, generate crypto values, and persist to storage.\n  const { provider, redirectURI, scope, loginHint } = configuration;\n  const { verifier, challenge, state } = await createCryptoChallenge();\n\n  /* Stringify for RN Async storage */\n  const storedData = JSON.stringify({\n    verifier,\n    state,\n  });\n\n  await this.utils.storage.setItem(OAUTH_REDIRECT_METADATA_KEY, storedData);\n\n  // Formulate the initial redirect query to Magic's OAuth hub.\n  // Required fields:\n  //   - `magic_api_key`\n  //   - `magic_challenge`\n  //   - `state`\n  //   - `redirect_uri`\n  //   - `platform`\n\n  const query = [\n    `magic_api_key=${encodeURIComponent(this.sdk.apiKey)}`,\n    `magic_challenge=${encodeURIComponent(challenge)}`,\n    `state=${encodeURIComponent(state)}`,\n    `platform=${encodeURIComponent('rn')}`,\n    scope && `scope=${encodeURIComponent(scope.join(' '))}`,\n    redirectURI && `redirect_uri=${encodeURIComponent(redirectURI)}`,\n    loginHint && `login_hint=${encodeURIComponent(loginHint)}`,\n  ].reduce((prev, next) => (next ? `${prev}&${next}` : prev));\n\n  return {\n    query,\n    provider,\n    redirectURI,\n  };\n}\n\nexport function getResult(this: OAuthExtension, queryString: string) {\n  return this.utils.createPromiEvent<OAuthRedirectResult>(async (resolve, reject) => {\n    const json: string = await this.utils.storage.getItem(OAUTH_REDIRECT_METADATA_KEY);\n\n    const { verifier, state } = JSON.parse(json);\n\n    // Remove the save OAuth state from storage, it stays in memory now...\n    this.utils.storage.removeItem(OAUTH_REDIRECT_METADATA_KEY);\n\n    const parseRedirectResult = this.utils.createJsonRpcRequestPayload(OAuthPayloadMethods.ParseRedirectResult, [\n      queryString,\n      verifier,\n      state,\n    ]);\n\n    // Parse the result, which may contain an OAuth-formatted error.\n    const resultOrError = await this.request<OAuthRedirectResult | OAuthRedirectError>(parseRedirectResult);\n    const maybeResult = resultOrError as OAuthRedirectResult;\n    const maybeError = resultOrError as OAuthRedirectError;\n\n    if (maybeError.error) {\n      reject(\n        this.createError<OAuthErrorData>(maybeError.error, maybeError.error_description ?? 'An error occurred.', {\n          errorURI: maybeError.error_uri,\n          provider: maybeError.provider,\n        }),\n      );\n    }\n\n    resolve(maybeResult);\n  });\n}\n\nexport * from './types';\n", "import { WordArray } from 'crypto-js';\nimport sha256Fallback from 'crypto-js/sha256';\nimport Base64 from 'crypto-js/enc-base64';\n\nconst CHARSET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~';\nconst HAS_CRYPTO = typeof window !== 'undefined' && !!(window.crypto as any);\nconst HAS_SUBTLE_CRYPTO = HAS_CRYPTO && !!(window.crypto.subtle as any);\n\n/**\n * Stringifies `bytes` using the OAuth 2.0 `code_verifier` character set.\n */\nfunction bytesToVerifierString(bytes: Uint8Array) {\n  return Array.from(bytes)\n    .map((value: number) => CHARSET[value % CHARSET.length])\n    .join('');\n}\n\n/**\n * Stringifies argument (as CryptoJS `WordArray` or EcmaScript `ArrayBuffer`)\n * and encodes to URL-safe Base64.\n */\nfunction base64URLEncodeFromByteArray(wordArray: WordArray): string;\nfunction base64URLEncodeFromByteArray(arrayBuffer: ArrayBuffer): string;\nfunction base64URLEncodeFromByteArray(arg: WordArray | ArrayBuffer): string {\n  const makeURLSafe = (base64: string) => {\n    return base64.replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=/g, '');\n  };\n\n  if (arg instanceof ArrayBuffer) {\n    const bytes = new Uint8Array(arg);\n    const utf8Binary = Array.from(bytes)\n      .map((value) => String.fromCharCode(value))\n      .join('');\n\n    const base64 = btoa(utf8Binary);\n    return makeURLSafe(base64);\n  }\n\n  return makeURLSafe(Base64.stringify(arg));\n}\n\n/**\n * Produces a SHA-256 hash of the given `message`. This function first attempts\n * to use the browser's built-in `SubtleCrypto` API, falling back to\n * CryptoJS if required.\n */\nasync function sha256(message: string) {\n  if (HAS_SUBTLE_CRYPTO) {\n    const bytes = new TextEncoder().encode(message);\n    return crypto.subtle.digest('SHA-256', bytes).then(base64URLEncodeFromByteArray);\n  }\n\n  return base64URLEncodeFromByteArray(sha256Fallback(message));\n}\n\n/**\n * Creates a cryptographically random string using the browser's built-in\n * `Crypto` API, falling back to `Math.random` if required.\n */\nfunction createRandomString(size: number) {\n  const bytes = new Uint8Array(size);\n\n  if (HAS_CRYPTO) {\n    window.crypto.getRandomValues(bytes);\n  } else {\n    for (let i = 0; i < size; i += 1) bytes[i] = Math.floor(Math.random() * Math.floor(255));\n  }\n\n  return bytesToVerifierString(bytes);\n}\n\n/**\n * Creates OAuth 2.0-compatible `code_verifier`, `code_challenge`, and `state`\n * parameters.\n */\nexport async function createCryptoChallenge() {\n  const state = createRandomString(128);\n  const verifier = createRandomString(128);\n  const challenge = await sha256(verifier);\n  return { verifier, challenge, state };\n}\n", "import { MagicUserMetadata } from '@magic-sdk/types';\n\nexport enum OAuthPayloadMethods {\n  ParseRedirectResult = 'magic_oauth_parse_redirect_result',\n}\n\nexport type OAuthProvider =\n  | 'google'\n  | 'facebook'\n  | 'apple'\n  | 'github'\n  | 'bitbucket'\n  | 'gitlab'\n  | 'linkedin'\n  | 'twitter'\n  | 'discord'\n  | 'twitch'\n  | 'microsoft';\n\nexport interface OAuthErrorData {\n  provider: OAuthProvider;\n  errorURI?: string;\n}\n\nexport interface OpenIDConnectProfile {\n  name?: string;\n  familyName?: string;\n  givenName?: string;\n  middleName?: string;\n  nickname?: string;\n  preferredUsername?: string;\n  profile?: string;\n  picture?: string;\n  website?: string;\n  gender?: string;\n  birthdate?: string;\n  zoneinfo?: string;\n  locale?: string;\n  updatedAt?: number;\n}\n\nexport interface OpenIDConnectEmail {\n  email?: string;\n  emailVerified?: boolean;\n}\n\nexport interface OpenIDConnectPhone {\n  phoneNumber?: string;\n  phoneNumberVerified?: boolean;\n}\n\nexport interface OpenIDConnectAddress {\n  address?: {\n    formatted?: string;\n    streetAddress?: string;\n    locality?: string;\n    region?: string;\n    postalCode?: string;\n    country?: string;\n  };\n}\n\nexport type OpenIDConnectUserInfo = OpenIDConnectProfile &\n  OpenIDConnectEmail &\n  OpenIDConnectPhone &\n  OpenIDConnectAddress & { sub?: string; sources?: Record<string, any> } & Record<string, any>;\n\nexport interface OAuthRedirectResult {\n  oauth: {\n    provider: OAuthProvider;\n    scope: string[];\n    accessToken: string;\n    userHandle: string;\n    userInfo: OpenIDConnectUserInfo;\n  };\n\n  magic: {\n    idToken: string;\n    userMetadata: MagicUserMetadata;\n  };\n}\n\nexport interface OAuthRedirectError {\n  provider: OAuthProvider;\n  error: string;\n  error_description?: string;\n  error_uri?: string;\n}\n\nexport interface OAuthRedirectConfiguration {\n  provider: OAuthProvider;\n  redirectURI: string;\n  scope?: string[];\n  loginHint?: string;\n}\n\nexport enum OAuthErrorCode {\n  InvalidRequest = 'invalid_request',\n  InvalidClient = 'invalid_client',\n  InvalidScope = 'invalid_scope',\n  InvalidGrant = 'invalid_grant',\n  UnauthorizedClient = 'unauthorized_client',\n  UnsupportedResponseType = 'unsupported_response_type',\n  UnsupportedGrantType = 'unsupported_grant_type',\n  UnsupportedTokenType = 'unsupported_token_type',\n  AccessDenied = 'access_denied',\n  ServerError = 'server_error',\n  TemporarilyUnavailable = 'temporarily_unavailable',\n}\n"],
  "mappings": "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",
  "names": ["src_exports", "__export", "OAuthErrorCode", "OAuthExtension", "OAuthPayloadMethods", "createURI", "getResult", "__toCommonJS", "WebBrowser", "import_react_native", "import_sha256", "import_enc_base64", "CHARSET", "HAS_CRYPTO", "HAS_SUBTLE_CRYPTO", "bytesToVerifierString", "bytes", "value", "base64URLEncodeFromByteArray", "arg", "makeURLSafe", "base64", "utf8Binary", "Base64", "sha256", "message", "__async", "sha256Fallback", "createRandomString", "size", "i", "createCryptoChallenge", "state", "verifier", "challenge", "OAuthPayloadMethods", "OAuthErrorCode", "OAuthExtension", "configuration", "resolve", "reject", "__async", "provider", "query", "redirectURI", "createURI", "url", "res", "queryString", "getResult", "err", "OAUTH_REDIRECT_METADATA_KEY", "scope", "loginHint", "verifier", "challenge", "state", "createCryptoChallenge", "storedData", "prev", "next", "_a", "json", "parseRedirectResult", "resultOrError", "maybeResult", "maybeError"]
}
